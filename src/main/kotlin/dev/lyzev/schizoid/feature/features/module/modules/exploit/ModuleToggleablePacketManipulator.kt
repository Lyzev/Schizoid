/*
 * Copyright (c) 2024. Schizoid
 * All rights reserved.
 */

package dev.lyzev.schizoid.feature.features.module.modules.exploit

import dev.lyzev.api.events.*
import dev.lyzev.api.setting.settings.OptionEnum
import dev.lyzev.api.setting.settings.multiOption
import dev.lyzev.api.setting.settings.option
import dev.lyzev.api.setting.settings.slider
import dev.lyzev.api.settings.Setting.Companion.neq
import dev.lyzev.schizoid.Schizoid
import dev.lyzev.schizoid.feature.IFeature
import dev.lyzev.schizoid.feature.features.module.ModuleToggleable
import net.minecraft.network.NetworkPhase
import net.minecraft.network.listener.PacketListener
import net.minecraft.network.packet.Packet
import net.minecraft.text.Text
import java.util.concurrent.CopyOnWriteArrayList

object ModuleToggleablePacketManipulator :
    ModuleToggleable("Packet Manipulator", "Manipulates S2C and C2S packets.", category = IFeature.Category.EXPLOIT),
    EventListener {

    val type by multiOption("Type", "Packets to manipulate.", EventPacket.Type.entries)

    val mode by option("Mode", "The mode of the packet manipulation.", Mode.Delay, Mode.entries)

    private var packets = CopyOnWriteArrayList<Triple<Packet<*>, EventPacket.Type, Long>>()

    override fun onEnable() {
        super.onEnable()
        type.firstOrNull { it.second } ?: run {
            sendChatMessage(Text.of("Please select a packet type."))
            toggle()
        }
    }

    override fun onDisable() {
        super.onDisable()
        for (packet in packets) {
            if (packet.second == EventPacket.Type.S2C) {
                runCatching {
                    @Suppress("UNCHECKED_CAST")
                    (packet.first as Packet<PacketListener>).apply(mc.networkHandler!!.connection.packetListener)
                }.onFailure {
                    Schizoid.logger.error("Failed to apply packet listener.", it)
                }
            } else {
                mc.networkHandler?.sendPacket(packet.first)
            }
            packets.remove(packet)
        }
        packets.clear()
    }

    override val shouldHandleEvents: Boolean
        get() = isEnabled && mc.networkHandler != null && type.firstOrNull { it.second } != null

    init {
        on<EventPacket>(Event.Priority.LOWEST) { event ->
            if (event.isCancelled) return@on
            if (mc.networkHandler?.phase != NetworkPhase.PLAY && mc.networkHandler?.phase != NetworkPhase.CONFIGURATION) {
                packets.clear()
                return@on
            }
            if ((event.type == EventPacket.Type.S2C && type.elementAt(0).second) || (event.type == EventPacket.Type.C2S && type.elementAt(
                    1
                ).second)
            ) {
                packets.add(Triple(event.packet, event.type, System.currentTimeMillis()))
                event.isCancelled = true
            }
        }
    }

    enum class Mode : OptionEnum, EventListener {
        Stop {

            override val shouldHandleEvents: Boolean
                get() = isEnabled && mode == this
        },
        Delay {

            val delay by slider(
                "Delay",
                "The delay of the packet manipulation.",
                1000,
                0,
                5000,
                "ms",
                hide = ::mode neq this
            )

            override val shouldHandleEvents: Boolean
                get() = isEnabled && mode == this && mc.networkHandler != null

            init {
                on<EventSwapBuffers> {
                    if (!mc.networkHandler!!.connection!!.isOpen) {
                        packets.clear()
                        return@on
                    }
                    for (packet in packets) {
                        if (System.currentTimeMillis() - packet.third >= delay) {
                            if (packet.second == EventPacket.Type.S2C) {
                                runCatching {
                                    @Suppress("UNCHECKED_CAST")
                                    (packet.first as Packet<PacketListener>).apply(mc.networkHandler!!.connection.packetListener)
                                }.onFailure {
                                    Schizoid.logger.error("Failed to apply packet listener.", it)
                                }
                            } else {
                                EventPacket.allowTrigger = false // Workaround: Prevent triggering the event recursively
                                mc.networkHandler?.sendPacket(packet.first)
                                EventPacket.allowTrigger = true
                            }
                            packets.remove(packet)
                        }
                    }
                }
            }
        };

        override val key = name
    }
}
